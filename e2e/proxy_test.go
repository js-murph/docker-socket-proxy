package e2e

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"os"
	"path/filepath"
	"testing"
	"time"

	"docker-socket-proxy/internal/application"
	"docker-socket-proxy/internal/domain"
	"docker-socket-proxy/internal/infrastructure/repository"
	httpInterface "docker-socket-proxy/internal/interfaces/http"
	"docker-socket-proxy/internal/logging"
)

func TestE2E_ProxyLifecycle(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Set up logging
	logging.SetLevel(slog.LevelDebug)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)

	// Create socket manager
	socketManager := application.NewSocketManager(tempDir)

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(NewMockDockerClient(), socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8080")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test socket creation
	t.Run("CreateSocket", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "test-socket",
			ListenAddress:   "", // Will be set by the service
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.42/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{Type: domain.ActionAllow, Reason: "Allowed to create containers"},
					},
				},
			},
		}

		socket, err := socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// The socket path should be generated by the service
		expectedPath := filepath.Join(socketManager.GetSocketDir(), "test-socket.sock")
		if socket.Path != expectedPath {
			t.Errorf("Expected socket path %s, got %s", expectedPath, socket.Path)
		}
	})

	// Test socket listing
	t.Run("ListSockets", func(t *testing.T) {
		sockets, err := socketService.ListSockets(serverCtx)
		if err != nil {
			t.Fatalf("Failed to list sockets: %v", err)
		}

		if len(sockets) != 1 {
			t.Errorf("Expected 1 socket, got %d", len(sockets))
		}

		if len(sockets) > 0 {
			expectedName := "test-socket"
			if sockets[0] != expectedName {
				t.Errorf("Expected socket name %s, got %s", expectedName, sockets[0])
			}
		}
	})

	// Test socket description
	t.Run("DescribeSocket", func(t *testing.T) {
		socketName := "test-socket"
		config, err := socketService.DescribeSocket(serverCtx, socketName)
		if err != nil {
			t.Fatalf("Failed to describe socket: %v", err)
		}

		if config.Name != "test-socket" {
			t.Errorf("Expected socket name 'test-socket', got '%s'", config.Name)
		}

		if len(config.Rules) != 1 {
			t.Errorf("Expected 1 rule, got %d", len(config.Rules))
		}
	})

	// Test socket deletion
	t.Run("DeleteSocket", func(t *testing.T) {
		socketName := "test-socket"
		err := socketService.DeleteSocket(serverCtx, socketName)
		if err != nil {
			t.Fatalf("Failed to delete socket: %v", err)
		}

		// Verify socket is deleted
		sockets, err := socketService.ListSockets(serverCtx)
		if err != nil {
			t.Fatalf("Failed to list sockets after deletion: %v", err)
		}

		if len(sockets) != 0 {
			t.Errorf("Expected 0 sockets after deletion, got %d", len(sockets))
		}
	})

	// Test socket cleanup
	t.Run("CleanSockets", func(t *testing.T) {
		// Create multiple sockets
		for i := 0; i < 3; i++ {
			config := domain.SocketConfig{
				Name:            fmt.Sprintf("test-socket-%d", i),
				ListenAddress:   "", // Will be set by the service
				DockerDaemonURL: "unix:///var/run/docker.sock",
				Rules:           []domain.Rule{},
			}

			_, err := socketService.CreateSocket(serverCtx, config)
			if err != nil {
				t.Fatalf("Failed to create socket %d: %v", i, err)
			}
		}

		// Verify sockets exist
		sockets, err := socketService.ListSockets(serverCtx)
		if err != nil {
			t.Fatalf("Failed to list sockets: %v", err)
		}

		if len(sockets) != 3 {
			t.Errorf("Expected 3 sockets, got %d", len(sockets))
		}

		// Clean all sockets
		err = socketService.CleanSockets(serverCtx)
		if err != nil {
			t.Fatalf("Failed to clean sockets: %v", err)
		}

		// Verify all sockets are cleaned
		sockets, err = socketService.ListSockets(serverCtx)
		if err != nil {
			t.Fatalf("Failed to list sockets after cleanup: %v", err)
		}

		if len(sockets) != 0 {
			t.Errorf("Expected 0 sockets after cleanup, got %d", len(sockets))
		}
	})

	// Stop server
	serverCancel()
	time.Sleep(100 * time.Millisecond)
}

func TestE2E_HTTPAPI(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)

	// Create socket manager
	socketManager := application.NewSocketManager(tempDir)

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(NewMockDockerClient(), socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8081")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Use serverCtx in the test
	_ = serverCtx

	// Test health endpoint
	t.Run("HealthEndpoint", func(t *testing.T) {
		resp, err := http.Get("http://localhost:8081/health")
		if err != nil {
			t.Fatalf("Failed to call health endpoint: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		var healthResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&healthResponse); err != nil {
			t.Fatalf("Failed to decode health response: %v", err)
		}

		if healthResponse["status"] != "healthy" {
			t.Errorf("Expected status 'healthy', got '%v'", healthResponse["status"])
		}
	})

	// Test socket creation via HTTP API
	t.Run("CreateSocketViaAPI", func(t *testing.T) {
		createRequest := map[string]interface{}{
			"name":              "test-socket",
			"listen_address":    filepath.Join(tempDir, "test-socket.sock"),
			"docker_daemon_url": "unix:///var/run/docker.sock",
			"rules": []map[string]interface{}{
				{
					"match": map[string]interface{}{
						"path":   "/v1.42/containers/create",
						"method": "POST",
					},
					"actions": []map[string]interface{}{
						{
							"action": "allow",
							"reason": "Allowed to create containers",
						},
					},
				},
			},
		}

		reqBody, _ := json.Marshal(createRequest)
		resp, err := http.Post("http://localhost:8081/socket/create", "application/json", bytes.NewReader(reqBody))
		if err != nil {
			t.Fatalf("Failed to call create socket endpoint: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusCreated {
			t.Errorf("Expected status 201, got %d", resp.StatusCode)
		}

		var createResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&createResponse); err != nil {
			t.Fatalf("Failed to decode create response: %v", err)
		}

		if !createResponse["success"].(bool) {
			t.Errorf("Expected success true, got %v", createResponse["success"])
		}
	})

	// Test socket listing via HTTP API
	t.Run("ListSocketsViaAPI", func(t *testing.T) {
		resp, err := http.Get("http://localhost:8081/socket/list")
		if err != nil {
			t.Fatalf("Failed to call list sockets endpoint: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		var listResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&listResponse); err != nil {
			t.Fatalf("Failed to decode list response: %v", err)
		}

		if !listResponse["success"].(bool) {
			t.Errorf("Expected success true, got %v", listResponse["success"])
		}

		sockets := listResponse["sockets"].([]interface{})
		if len(sockets) != 1 {
			t.Errorf("Expected 1 socket, got %d", len(sockets))
		}
	})

	// Test socket description via HTTP API
	t.Run("DescribeSocketViaAPI", func(t *testing.T) {
		socketName := "test-socket"
		resp, err := http.Get(fmt.Sprintf("http://localhost:8081/socket/describe?socket=%s", socketName))
		if err != nil {
			t.Fatalf("Failed to call describe socket endpoint: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		var describeResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&describeResponse); err != nil {
			t.Fatalf("Failed to decode describe response: %v", err)
		}

		if !describeResponse["success"].(bool) {
			t.Errorf("Expected success true, got %v", describeResponse["success"])
		}
	})

	// Test socket deletion via HTTP API
	t.Run("DeleteSocketViaAPI", func(t *testing.T) {
		socketName := "test-socket"
		req, _ := http.NewRequest("DELETE", fmt.Sprintf("http://localhost:8081/socket/delete?socket=%s", socketName), nil)
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to call delete socket endpoint: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		var deleteResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&deleteResponse); err != nil {
			t.Fatalf("Failed to decode delete response: %v", err)
		}

		if !deleteResponse["success"].(bool) {
			t.Errorf("Expected success true, got %v", deleteResponse["success"])
		}
	})

	// Test socket cleanup via HTTP API
	t.Run("CleanSocketsViaAPI", func(t *testing.T) {
		// Create multiple sockets first
		for i := 0; i < 3; i++ {
			createRequest := map[string]interface{}{
				"name":              fmt.Sprintf("test-socket-%d", i),
				"listen_address":    filepath.Join(tempDir, fmt.Sprintf("test-socket-%d.sock", i)),
				"docker_daemon_url": "unix:///var/run/docker.sock",
				"rules":             []map[string]interface{}{},
			}

			reqBody, _ := json.Marshal(createRequest)
			resp, err := http.Post("http://localhost:8081/socket/create", "application/json", bytes.NewReader(reqBody))
			if err != nil {
				t.Fatalf("Failed to create socket %d: %v", i, err)
			}
			resp.Body.Close()
		}

		// Clean all sockets
		req, _ := http.NewRequest("POST", "http://localhost:8081/socket/clean", nil)
		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to call clean sockets endpoint: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		var cleanResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&cleanResponse); err != nil {
			t.Fatalf("Failed to decode clean response: %v", err)
		}

		if !cleanResponse["success"].(bool) {
			t.Errorf("Expected success true, got %v", cleanResponse["success"])
		}
	})

	// Stop server
	serverCancel()
	time.Sleep(100 * time.Millisecond)
}

func TestE2E_ProxyRequestHandling(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)

	// Create socket manager
	socketManager := application.NewSocketManager(tempDir)

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(NewMockDockerClient(), socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8082")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Create a socket with rules
	config := domain.SocketConfig{
		Name:            "test-socket",
		ListenAddress:   "", // Will be set by the service
		DockerDaemonURL: "unix:///var/run/docker.sock",
		Rules: []domain.Rule{
			{
				Match: domain.Match{
					Path:   "/v1.42/containers/create",
					Method: "POST",
				},
				Actions: []domain.Action{
					{Type: domain.ActionAllow, Reason: "Allowed to create containers"},
				},
			},
			{
				Match: domain.Match{
					Path:   "/v1.42/containers/.*/start",
					Method: "POST",
				},
				Actions: []domain.Action{
					{Type: domain.ActionDeny, Reason: "Container start not allowed"},
				},
			},
		},
	}

	_, err = socketService.CreateSocket(serverCtx, config)
	if err != nil {
		t.Fatalf("Failed to create socket: %v", err)
	}

	// Test proxy request handling
	t.Run("ProxyRequest", func(t *testing.T) {
		// Create a request that should be allowed
		req, _ := http.NewRequest("POST", "http://localhost:8082/v1.42/containers/create", bytes.NewReader([]byte(`{"Image":"nginx"}`)))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "test-socket")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make proxy request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}
	})

	// Test proxy request handling with denial
	t.Run("ProxyRequestDenied", func(t *testing.T) {
		// Create a request that should be denied
		req, _ := http.NewRequest("POST", "http://localhost:8082/v1.42/containers/123/start", nil)
		req.Header.Set("Socket-Name", "test-socket")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make proxy request: %v", err)
		}
		defer resp.Body.Close()

		// The request should be denied, but our mock returns 200
		// This should return 403 Forbidden for denied requests
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}
	})

	// Stop server
	serverCancel()
	time.Sleep(100 * time.Millisecond)
}

// TestE2E_RewritingUpsert tests the upsert action for request rewriting
// Based on docs/docs/configuration/rules.md - Upsert Action section
func TestE2E_RewritingUpsert(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)
	socketManager := application.NewSocketManager(tempDir)
	mockClient := NewMockDockerClient()

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(mockClient, socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8083")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()
	defer serverCancel()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test 1: Force read-only root filesystem (from docs example)
	t.Run("ForceReadOnlyRootfs", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "upsert-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"HostConfig": map[string]interface{}{
									"ReadonlyRootfs": true,
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged": false,
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8083/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "upsert-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the request was modified
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		// Debug: Print the modified body
		t.Logf("Modified body: %+v", modifiedBody)

		hostConfig, ok := modifiedBody["HostConfig"].(map[string]interface{})
		if !ok {
			t.Fatalf("HostConfig not found in modified request")
		}

		readonlyRootfs, exists := hostConfig["ReadonlyRootfs"]
		if !exists {
			t.Errorf("ReadonlyRootfs not added to HostConfig")
		} else if readonlyRootfs != true {
			t.Errorf("Expected ReadonlyRootfs to be true, got %v", readonlyRootfs)
		}

		// Verify original field is preserved
		if privileged, exists := hostConfig["Privileged"]; !exists || privileged != false {
			t.Errorf("Original Privileged field was not preserved")
		}
	})

	// Test 2: Add environment variables
	t.Run("AddEnvironmentVariables", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "env-upsert-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"Env": []interface{}{
									"SECURE=true",
									"DEBUG=false",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with existing env vars
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"EXISTING_VAR=value",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8083/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "env-upsert-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the environment variables were added
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		envVars, ok := modifiedBody["Env"].([]interface{})
		if !ok {
			t.Fatalf("Env not found or not an array in modified request")
		}

		// Check that all expected env vars are present
		expectedVars := []string{"EXISTING_VAR=value", "SECURE=true", "DEBUG=false"}
		for _, expected := range expectedVars {
			found := false
			for _, envVar := range envVars {
				if envVar == expected {
					found = true
					break
				}
			}
			if !found {
				t.Errorf("Expected environment variable %s not found in %v", expected, envVars)
			}
		}
	})

	// Test 3: Add required labels
	t.Run("AddRequiredLabels", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "labels-upsert-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"Labels": map[string]interface{}{
									"socket-proxy": "docker-socket-proxy",
									"security":     "enforced",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request
		reqBody := map[string]interface{}{
			"Image": "nginx",
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8083/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "labels-upsert-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the labels were added
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		labels, ok := modifiedBody["Labels"].(map[string]interface{})
		if !ok {
			t.Fatalf("Labels not found in modified request")
		}

		if labels["socket-proxy"] != "docker-socket-proxy" {
			t.Errorf("Expected socket-proxy label, got %v", labels["socket-proxy"])
		}
		if labels["security"] != "enforced" {
			t.Errorf("Expected security label, got %v", labels["security"])
		}
	})

	time.Sleep(100 * time.Millisecond)
}

// TestE2E_RewritingReplace tests the replace action for request rewriting
// Based on docs/docs/configuration/rules.md - Replace Action section
func TestE2E_RewritingReplace(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)
	socketManager := application.NewSocketManager(tempDir)
	mockClient := NewMockDockerClient()

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(mockClient, socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8089")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()
	defer serverCancel()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test 1: Disable privileged mode when detected (from docs example)
	t.Run("DisablePrivilegedMode", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "replace-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionReplace,
							Contains: map[string]interface{}{
								"HostConfig": map[string]interface{}{
									"Privileged": true,
								},
							},
							Update: map[string]interface{}{
								"HostConfig": map[string]interface{}{
									"Privileged": false,
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with privileged mode
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged": true,
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8089/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "replace-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the request was modified
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		hostConfig, ok := modifiedBody["HostConfig"].(map[string]interface{})
		if !ok {
			t.Fatalf("HostConfig not found in modified request")
		}

		privileged, exists := hostConfig["Privileged"]
		if !exists {
			t.Errorf("Privileged field not found in HostConfig")
		} else if privileged != false {
			t.Errorf("Expected Privileged to be false, got %v", privileged)
		}
	})

	// Test 2: Replace image with secure version
	t.Run("ReplaceImageWithSecureVersion", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "image-replace-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionReplace,
							Contains: map[string]interface{}{
								"Image": "nginx:latest",
							},
							Update: map[string]interface{}{
								"Image": "nginx:alpine",
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with nginx:latest
		reqBody := map[string]interface{}{
			"Image": "nginx:latest",
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8089/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "image-replace-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the image was replaced
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		image, exists := modifiedBody["Image"]
		if !exists {
			t.Errorf("Image field not found in modified request")
		} else if image != "nginx:alpine" {
			t.Errorf("Expected Image to be 'nginx:alpine', got %v", image)
		}
	})

	// Test 3: Replace environment variables
	t.Run("ReplaceEnvironmentVariables", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "env-replace-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionReplace,
							Contains: map[string]interface{}{
								"Env": []interface{}{
									"DEBUG=true",
								},
							},
							Update: map[string]interface{}{
								"Env": []interface{}{
									"DEBUG=false",
									"SECURE=true",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with DEBUG=true
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"DEBUG=true",
				"OTHER_VAR=value",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8089/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "env-replace-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the environment variables were replaced
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		envVars, ok := modifiedBody["Env"].([]interface{})
		if !ok {
			t.Fatalf("Env not found or not an array in modified request")
		}

		// Check that DEBUG=false and SECURE=true are present
		expectedVars := []string{"DEBUG=false", "SECURE=true"}
		for _, expected := range expectedVars {
			found := false
			for _, envVar := range envVars {
				if envVar == expected {
					found = true
					break
				}
			}
			if !found {
				t.Errorf("Expected environment variable %s not found in %v", expected, envVars)
			}
		}

		// Check that DEBUG=true was replaced (not present)
		for _, envVar := range envVars {
			if envVar == "DEBUG=true" {
				t.Errorf("DEBUG=true should have been replaced, but found in %v", envVars)
			}
		}
	})

	time.Sleep(100 * time.Millisecond)
}

// TestE2E_RewritingDelete tests the delete action for request rewriting
// Based on docs/docs/configuration/rules.md - Delete Action section
func TestE2E_RewritingDelete(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)
	socketManager := application.NewSocketManager(tempDir)
	mockClient := NewMockDockerClient()

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(mockClient, socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8085")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()
	defer serverCancel()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test 1: Remove sensitive environment variables (from docs example)
	t.Run("RemoveSensitiveEnvironmentVariables", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "delete-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionDelete,
							Contains: map[string]interface{}{
								"Env": []interface{}{
									"AWS_SECRET_.*",
									"PASSWORD=.*",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with sensitive env vars
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"AWS_SECRET_ACCESS_KEY=secret123",
				"PASSWORD=password123",
				"SAFE_VAR=safe_value",
				"DEBUG=true",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8085/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "delete-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the sensitive environment variables were removed
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		envVars, ok := modifiedBody["Env"].([]interface{})
		if !ok {
			t.Fatalf("Env not found or not an array in modified request")
		}

		// Check that sensitive vars are not present
		sensitiveVars := []string{"AWS_SECRET_ACCESS_KEY=secret123", "PASSWORD=password123"}
		for _, sensitive := range sensitiveVars {
			for _, envVar := range envVars {
				if envVar == sensitive {
					t.Errorf("Sensitive environment variable %s should have been removed, but found in %v", sensitive, envVars)
				}
			}
		}

		// Check that safe vars are still present
		safeVars := []string{"SAFE_VAR=safe_value", "DEBUG=true"}
		for _, safe := range safeVars {
			found := false
			for _, envVar := range envVars {
				if envVar == safe {
					found = true
					break
				}
			}
			if !found {
				t.Errorf("Safe environment variable %s should not have been removed, but not found in %v", safe, envVars)
			}
		}
	})

	// Test 2: Remove privileged mode from HostConfig
	t.Run("RemovePrivilegedMode", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "privileged-delete-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionDelete,
							Contains: map[string]interface{}{
								"HostConfig": map[string]interface{}{
									"Privileged": true,
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with privileged mode
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged":     true,
				"ReadonlyRootfs": false,
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8085/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "privileged-delete-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the privileged field was removed
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		hostConfig, ok := modifiedBody["HostConfig"].(map[string]interface{})
		if !ok {
			t.Fatalf("HostConfig not found in modified request")
		}

		// Privileged should not be present
		if _, exists := hostConfig["Privileged"]; exists {
			t.Errorf("Privileged field should have been removed from HostConfig")
		}

		// Other fields should be preserved
		if readonlyRootfs, exists := hostConfig["ReadonlyRootfs"]; !exists || readonlyRootfs != false {
			t.Errorf("ReadonlyRootfs field should have been preserved")
		}
	})

	// Test 3: Remove entire field
	t.Run("RemoveEntireField", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "field-delete-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionDelete,
							Contains: map[string]interface{}{
								"Labels": "anyValue",
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with labels
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Labels": map[string]interface{}{
				"test": "value",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8085/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "field-delete-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the labels field was removed
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		if _, exists := modifiedBody["Labels"]; exists {
			t.Errorf("Labels field should have been removed from request")
		}

		// Image should still be present
		if image, exists := modifiedBody["Image"]; !exists || image != "nginx" {
			t.Errorf("Image field should have been preserved")
		}
	})

	time.Sleep(100 * time.Millisecond)
}

// TestE2E_ContentMatching tests content matching based on request body contents
// Based on docs/docs/configuration/rules.md - Match Criteria section
func TestE2E_ContentMatching(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)
	socketManager := application.NewSocketManager(tempDir)
	mockClient := NewMockDockerClient()

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(mockClient, socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8086")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()
	defer serverCancel()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test 1: Deny privileged containers (from docs example)
	t.Run("DenyPrivilegedContainers", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "privileged-deny-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
						Contains: map[string]interface{}{
							"HostConfig": map[string]interface{}{
								"Privileged": true,
							},
						},
					},
					Actions: []domain.Action{
						{Type: domain.ActionDeny, Reason: "Privileged containers are not allowed"},
					},
				},
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{Type: domain.ActionAllow, Reason: "Non-privileged containers allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Test 1a: Privileged container should be denied
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged": true,
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8086/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "privileged-deny-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		// This should return 403 Forbidden for privileged containers
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}

		// Test 1b: Non-privileged container should be allowed
		mockClient.Clear()

		reqBody = map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged": false,
			},
		}
		bodyBytes, _ = json.Marshal(reqBody)

		req, _ = http.NewRequest("POST", "http://localhost:8086/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "privileged-deny-test")

		resp, err = http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the request was processed (reached the mock)
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured for non-privileged container")
		}
	})

	// Test 2: Deny based on environment variable presence
	t.Run("DenyBasedOnEnvironmentVariable", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "env-deny-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
						Contains: map[string]interface{}{
							"Env": []interface{}{
								"BLOCK=true",
							},
						},
					},
					Actions: []domain.Action{
						{Type: domain.ActionDeny, Reason: "Blocked creation of containers with restricted env variables"},
					},
				},
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{Type: domain.ActionAllow, Reason: "Allowed container creation"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Test 2a: Container with BLOCK=true should be denied
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"BLOCK=true",
				"OTHER_VAR=value",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8086/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "env-deny-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		// This should return 403 Forbidden for denied requests
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}

		// Test 2b: Container without BLOCK=true should be allowed
		mockClient.Clear()

		reqBody = map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"SAFE_VAR=value",
			},
		}
		bodyBytes, _ = json.Marshal(reqBody)

		req, _ = http.NewRequest("POST", "http://localhost:8086/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "env-deny-test")

		resp, err = http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the request was processed
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured for safe container")
		}
	})

	// Test 3: Complex nested matching
	t.Run("ComplexNestedMatching", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "nested-match-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
						Contains: map[string]interface{}{
							"HostConfig": map[string]interface{}{
								"Binds": []interface{}{
									"/var/run/docker.sock:/var/run/docker.sock",
								},
							},
						},
					},
					Actions: []domain.Action{
						{Type: domain.ActionDeny, Reason: "Docker socket bind mounts are not allowed"},
					},
				},
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{Type: domain.ActionAllow, Reason: "Allowed container creation"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Test 3a: Container with Docker socket bind should be denied
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Binds": []interface{}{
					"/var/run/docker.sock:/var/run/docker.sock",
					"/tmp:/tmp",
				},
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8086/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "nested-match-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		// This should return 403 Forbidden for denied requests
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}

		// Test 3b: Container without Docker socket bind should be allowed
		mockClient.Clear()

		reqBody = map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Binds": []interface{}{
					"/tmp:/tmp",
				},
			},
		}
		bodyBytes, _ = json.Marshal(reqBody)

		req, _ = http.NewRequest("POST", "http://localhost:8086/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "nested-match-test")

		resp, err = http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the request was processed
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured for safe container")
		}
	})

	time.Sleep(100 * time.Millisecond)
}

// TestE2E_MultipleActions tests multiple actions in sequence
// Based on docs/docs/configuration/rules.md - Processing Order section
func TestE2E_MultipleActions(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)
	socketManager := application.NewSocketManager(tempDir)
	mockClient := NewMockDockerClient()

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(mockClient, socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8087")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()
	defer serverCancel()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test 1: Upsert + Allow sequence
	t.Run("UpsertThenAllow", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "multi-action-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"Labels": map[string]interface{}{
									"security": "enforced",
								},
							},
						},
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"HostConfig": map[string]interface{}{
									"ReadonlyRootfs": true,
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request
		reqBody := map[string]interface{}{
			"Image": "nginx",
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8087/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "multi-action-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify both modifications were applied
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		// Check labels were added
		labels, ok := modifiedBody["Labels"].(map[string]interface{})
		if !ok {
			t.Fatalf("Labels not found in modified request")
		}
		if labels["security"] != "enforced" {
			t.Errorf("Expected security label, got %v", labels["security"])
		}

		// Check HostConfig was modified
		hostConfig, ok := modifiedBody["HostConfig"].(map[string]interface{})
		if !ok {
			t.Fatalf("HostConfig not found in modified request")
		}
		if readonlyRootfs, exists := hostConfig["ReadonlyRootfs"]; !exists || readonlyRootfs != true {
			t.Errorf("Expected ReadonlyRootfs to be true, got %v", readonlyRootfs)
		}
	})

	// Test 2: Replace + Upsert sequence
	t.Run("ReplaceThenUpsert", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "replace-upsert-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionReplace,
							Contains: map[string]interface{}{
								"Image": "nginx:latest",
							},
							Update: map[string]interface{}{
								"Image": "nginx:alpine",
							},
						},
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"Env": []interface{}{
									"SECURE=true",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with nginx:latest
		reqBody := map[string]interface{}{
			"Image": "nginx:latest",
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8087/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "replace-upsert-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify both modifications were applied
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		// Check image was replaced
		if image, exists := modifiedBody["Image"]; !exists || image != "nginx:alpine" {
			t.Errorf("Expected Image to be 'nginx:alpine', got %v", image)
		}

		// Check environment variable was added
		envVars, ok := modifiedBody["Env"].([]interface{})
		if !ok {
			t.Fatalf("Env not found or not an array in modified request")
		}
		found := false
		for _, envVar := range envVars {
			if envVar == "SECURE=true" {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected environment variable SECURE=true not found in %v", envVars)
		}
	})

	// Test 3: Delete + Upsert sequence
	t.Run("DeleteThenUpsert", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "delete-upsert-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionDelete,
							Contains: map[string]interface{}{
								"Env": []interface{}{
									"DEBUG=.*",
								},
							},
						},
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"Env": []interface{}{
									"SECURE=true",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Modified and allowed"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Send a container creation request with DEBUG env var
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"DEBUG=true",
				"OTHER_VAR=value",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8087/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "delete-upsert-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify both modifications were applied
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		envVars, ok := modifiedBody["Env"].([]interface{})
		if !ok {
			t.Fatalf("Env not found or not an array in modified request")
		}

		// Check DEBUG was removed
		for _, envVar := range envVars {
			if envVar == "DEBUG=true" {
				t.Errorf("DEBUG=true should have been removed, but found in %v", envVars)
			}
		}

		// Check SECURE was added
		found := false
		for _, envVar := range envVars {
			if envVar == "SECURE=true" {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected environment variable SECURE=true not found in %v", envVars)
		}

		// Check OTHER_VAR was preserved
		found = false
		for _, envVar := range envVars {
			if envVar == "OTHER_VAR=value" {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("OTHER_VAR=value should have been preserved, but not found in %v", envVars)
		}
	})

	time.Sleep(100 * time.Millisecond)
}

// TestE2E_ComplexScenarios tests real-world use cases from documentation
// Based on examples from docs/docs/index.md and docs/docs/configuration/rules.md
func TestE2E_ComplexScenarios(t *testing.T) {
	// Create temporary directory for testing
	tempDir, err := os.MkdirTemp("", "docker-socket-proxy-e2e")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Create repository
	repo := repository.NewFileSocketRepository(tempDir)
	socketManager := application.NewSocketManager(tempDir)
	mockClient := NewMockDockerClient()

	// Create services
	socketService := application.NewSocketService(repo, socketManager)
	proxyService := application.NewProxyService(mockClient, socketManager)

	// Create server
	server := httpInterface.NewServer(socketService, proxyService, ":8088")

	// Start server in background
	serverCtx, serverCancel := context.WithCancel(context.Background())
	go func() {
		if err := server.Start(); err != nil {
			t.Errorf("Server failed to start: %v", err)
		}
	}()
	defer serverCancel()

	// Wait for server to start
	time.Sleep(100 * time.Millisecond)

	// Test 1: Complete security policy from docs example
	t.Run("CompleteSecurityPolicy", func(t *testing.T) {
		config := domain.SocketConfig{
			Name:            "security-policy-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				// Deny privileged containers
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
						Contains: map[string]interface{}{
							"HostConfig": map[string]interface{}{
								"Privileged": true,
							},
						},
					},
					Actions: []domain.Action{
						{Type: domain.ActionDeny, Reason: "Privileged containers are not allowed"},
					},
				},
				// Force read-only root filesystem
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"HostConfig": map[string]interface{}{
									"ReadonlyRootfs": true,
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Security policy applied"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Test 1a: Privileged container should be denied
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged": true,
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8088/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "security-policy-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		// This should return 403 Forbidden for denied requests
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}

		// Test 1b: Non-privileged container should be allowed with security modifications
		mockClient.Clear()

		reqBody = map[string]interface{}{
			"Image": "nginx",
			"HostConfig": map[string]interface{}{
				"Privileged": false,
			},
		}
		bodyBytes, _ = json.Marshal(reqBody)

		req, _ = http.NewRequest("POST", "http://localhost:8088/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "security-policy-test")

		resp, err = http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify security policy was applied
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		hostConfig, ok := modifiedBody["HostConfig"].(map[string]interface{})
		if !ok {
			t.Fatalf("HostConfig not found in modified request")
		}

		if readonlyRootfs, exists := hostConfig["ReadonlyRootfs"]; !exists || readonlyRootfs != true {
			t.Errorf("Expected ReadonlyRootfs to be true, got %v", readonlyRootfs)
		}
	})

	// Test 2: Volume access control from docs example
	t.Run("VolumeAccessControl", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "volume-control-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				// Deny volume listing
				{
					Match: domain.Match{
						Path:   "/v1.*/volumes",
						Method: "GET",
					},
					Actions: []domain.Action{
						{Type: domain.ActionDeny, Reason: "Listing volumes is restricted"},
					},
				},
				// Allow other requests
				{
					Match: domain.Match{
						Path:   "/.*",
						Method: ".*",
					},
					Actions: []domain.Action{
						{Type: domain.ActionAllow, Reason: "Allow all other requests"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Test 2a: Volume listing should be denied
		req, _ := http.NewRequest("GET", "http://localhost:8088/v1.42/volumes", nil)
		req.Header.Set("Socket-Name", "volume-control-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		// This should return 403 Forbidden for denied requests
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}

		// Test 2b: Container creation should be allowed
		mockClient.Clear()

		reqBody := map[string]interface{}{
			"Image": "nginx",
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ = http.NewRequest("POST", "http://localhost:8088/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "volume-control-test")

		resp, err = http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify the request was processed
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured for container creation")
		}
	})

	// Test 3: Environment variable filtering and modification
	t.Run("EnvironmentVariableFiltering", func(t *testing.T) {
		mockClient.Clear()

		config := domain.SocketConfig{
			Name:            "env-filter-test",
			ListenAddress:   "", // Auto-generated
			DockerDaemonURL: "unix:///var/run/docker.sock",
			Rules: []domain.Rule{
				// Deny containers with BLOCK=true
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
						Contains: map[string]interface{}{
							"Env": []interface{}{
								"BLOCK=true",
							},
						},
					},
					Actions: []domain.Action{
						{Type: domain.ActionDeny, Reason: "Blocked creation of containers with restricted env variables"},
					},
				},
				// Remove sensitive environment variables
				{
					Match: domain.Match{
						Path:   "/v1.*/containers/create",
						Method: "POST",
					},
					Actions: []domain.Action{
						{
							Type: domain.ActionDelete,
							Contains: map[string]interface{}{
								"Env": []interface{}{
									"AWS_SECRET_.*",
									"PASSWORD=.*",
								},
							},
						},
						// Add required security environment variables
						{
							Type: domain.ActionUpsert,
							Update: map[string]interface{}{
								"Env": []interface{}{
									"SECURE=true",
								},
							},
						},
						{Type: domain.ActionAllow, Reason: "Environment filtered and secured"},
					},
				},
			},
		}

		_, err = socketService.CreateSocket(serverCtx, config)
		if err != nil {
			t.Fatalf("Failed to create socket: %v", err)
		}

		// Test 3a: Container with BLOCK=true should be denied
		reqBody := map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"BLOCK=true",
			},
		}
		bodyBytes, _ := json.Marshal(reqBody)

		req, _ := http.NewRequest("POST", "http://localhost:8088/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "env-filter-test")

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		// This should return 403 Forbidden for denied requests
		if resp.StatusCode != http.StatusForbidden {
			t.Errorf("Expected status 403 Forbidden, got %d", resp.StatusCode)
		}

		// Test 3b: Container with sensitive env vars should be filtered and allowed
		mockClient.Clear()

		reqBody = map[string]interface{}{
			"Image": "nginx",
			"Env": []interface{}{
				"AWS_SECRET_ACCESS_KEY=secret123",
				"PASSWORD=password123",
				"SAFE_VAR=value",
			},
		}
		bodyBytes, _ = json.Marshal(reqBody)

		req, _ = http.NewRequest("POST", "http://localhost:8088/v1.42/containers/create", bytes.NewReader(bodyBytes))
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("Socket-Name", "env-filter-test")

		resp, err = http.DefaultClient.Do(req)
		if err != nil {
			t.Fatalf("Failed to make request: %v", err)
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			t.Errorf("Expected status 200, got %d", resp.StatusCode)
		}

		// Verify environment variables were filtered and secured
		modifiedBody := mockClient.GetLastRequestBody()
		if modifiedBody == nil {
			t.Fatalf("No request body captured")
		}

		envVars, ok := modifiedBody["Env"].([]interface{})
		if !ok {
			t.Fatalf("Env not found or not an array in modified request")
		}

		// Check sensitive vars were removed
		sensitiveVars := []string{"AWS_SECRET_ACCESS_KEY=secret123", "PASSWORD=password123"}
		for _, sensitive := range sensitiveVars {
			for _, envVar := range envVars {
				if envVar == sensitive {
					t.Errorf("Sensitive environment variable %s should have been removed, but found in %v", sensitive, envVars)
				}
			}
		}

		// Check SECURE was added
		found := false
		for _, envVar := range envVars {
			if envVar == "SECURE=true" {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected environment variable SECURE=true not found in %v", envVars)
		}

		// Check SAFE_VAR was preserved
		found = false
		for _, envVar := range envVars {
			if envVar == "SAFE_VAR=value" {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("SAFE_VAR=value should have been preserved, but not found in %v", envVars)
		}
	})

	time.Sleep(100 * time.Millisecond)
}

// MockDockerClient is a mock implementation of DockerClient for testing
type MockDockerClient struct {
	// CapturedRequests stores the requests that were made to the mock
	CapturedRequests []*http.Request
	// RequestBodies stores the parsed request bodies
	RequestBodies []map[string]interface{}
}

func NewMockDockerClient() *MockDockerClient {
	return &MockDockerClient{
		CapturedRequests: make([]*http.Request, 0),
		RequestBodies:    make([]map[string]interface{}, 0),
	}
}

func (m *MockDockerClient) Do(req *http.Request) (*http.Response, error) {
	// Capture the request
	m.CapturedRequests = append(m.CapturedRequests, req)

	// Parse and capture the request body
	var body map[string]interface{}
	if req.Body != nil {
		bodyBytes, err := io.ReadAll(req.Body)
		if err == nil && len(bodyBytes) > 0 {
			json.Unmarshal(bodyBytes, &body)
		}
		// Restore the body for potential re-reading
		req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
	}
	m.RequestBodies = append(m.RequestBodies, body)

	// Return a mock response
	return &http.Response{
		StatusCode: http.StatusOK,
		Body:       io.NopCloser(bytes.NewReader([]byte(`{"message":"mock response"}`))),
		Header:     make(http.Header),
	}, nil
}

// GetLastRequestBody returns the last captured request body
func (m *MockDockerClient) GetLastRequestBody() map[string]interface{} {
	if len(m.RequestBodies) == 0 {
		return nil
	}
	return m.RequestBodies[len(m.RequestBodies)-1]
}

// GetRequestBodyByIndex returns the request body at the specified index
func (m *MockDockerClient) GetRequestBodyByIndex(index int) map[string]interface{} {
	if index < 0 || index >= len(m.RequestBodies) {
		return nil
	}
	return m.RequestBodies[index]
}

// Clear clears all captured requests and bodies
func (m *MockDockerClient) Clear() {
	m.CapturedRequests = make([]*http.Request, 0)
	m.RequestBodies = make([]map[string]interface{}, 0)
}
